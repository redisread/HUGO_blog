---
title: 85Java 序列化的替代方案
date: 2021-11-20T17:46:03+08:00
description:
draft: true
hideToc: false
enableToc: true
enableTocContent: false
tocPosition: outer
author: Victor
authorEmoji: 🪶
image:
plantuml: true
libraries:
- katex
- mathjax
tags:
-
series:
-
categories:
-
---





Java序列化解决什么问题？

1. 实现持久化存储。
2. 实现分布式对象。（只要实现了序列化和反序列化）



序列化攻击

ObjectInputStream 上的 readObject 反序列化方法进行构建任何的对象，只要该类型实现 Serializable 接口。

> 在反序列化字节流的过程中，此方法可以执行来自任何这些类型的代码，因此所有这些类型的代码都在攻击范围内。

Java 反序列化是一个明显且真实的危险源，因为它被应用程序直接和间接地广泛使用，比如 RMI（远程方法调用）、JMX（Java 管理扩展）和 JMS（Java 消息传递系统）。不可信流的反序列化可能导致远程代码执行（RCE）、拒绝服务（DoS）和一系列其他攻击。应用程序很容易受到这些攻击，即使它们本身没有错误。





攻击者可以在反序列化方法里面添加攻击逻辑：

1. 无用的计算，将资源耗尽。
2. 调用系统危险的方法。



**避免序列化利用的最好方法是永远不要反序列化任何东西。没有理由在你编写的任何新系统中使用 Java 序列化。**



替代方案：

1. JSON

   JSON 由 Douglas Crockford 设计用于浏览器与服务器通信。最初为JS开发。

   优势：

   1. JSON 是基于文本的，并且是人类可读的。
   2.  是一种专门的数据表示

2.  Protocol Buffers（protobuf）

   Protocol Buffers 由谷歌设计用于在其服务器之间存储和交换结构化数据。最初为C++开发。

   优势：

   1. protobuf 是二进制的，效率更高
   2. 提供模式（类型）来记录和执行适当的用法



如果无法避免序列化，并且不能绝对确定反序列化数据的安全性，那么可以使用 Java 9 中添加的对象反序列化筛选，并将其移植到早期版本（java.io.ObjectInputFilter）。该工具允许你指定一个过滤器，该过滤器在反序列化数据流之前应用于数据流。它在类粒度上运行，允许你接受或拒绝某些类。默认接受所有类，并拒绝已知潜在危险类的列表称为黑名单；在默认情况下拒绝其他类，并接受假定安全的类的列表称为白名单。**优先选择白名单而不是黑名单，** 因为黑名单只保护你免受已知的威胁。



总之，序列化是危险的，应该避免。如果你从头开始设计一个系统，可以使用跨平台的结构化数据，如 JSON 或 protobuf。不要反序列化不可信的数据。如果必须这样做，请使用对象反序列化过滤，但要注意，它不能保证阻止所有攻击。避免编写可序列化的类。如果你必须这样做，一定要非常小心。



---

***Reference***:

