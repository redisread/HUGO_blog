---
title: 35使用实例字段替代序数
date: 2021-11-08T19:54:47+08:00
description:
draft: true
hideToc: false
enableToc: true
enableTocContent: false
tocPosition: outer
author: Victor
authorEmoji: 🪶
image:
plantuml: true
libraries:
- katex
- mathjax
tags:
-
series:
-
categories:
-
---





### 枚举元素默认序号

所有枚举都有一个 ordinal 方法，该方法返回枚举类型中每个枚举常数的数值位置。一个例子：

```java
public enum Ensemble {
    SOLO, DUET, TRIO, QUARTET, QUINTET, SEXTET, SEPTET, OCTET, NONET, DECTET;

    public int numberOfMusicians() {
        return ordinal() + 1;
    }
}
```

`ordinal` 方法会返回当前enum元素的位置（默认从0开始），执行 `SOLO.numberOfMusicians()` 之后方法。

**问题：**

使用这个方法虽然很方便，我们不用手动设置字段的序号，但是如果常量被重新排序，那原来调用 `ordinal` 的字段顺序也将改变，这使得代码维护更加困难。



### 设置序号

最好的方法是**不要使用`ordinal` 方法获取枚举元素的序号，而是自己手动设置枚举元素的序号**。这样的好处是：

1. 不必担心枚举元素重排序。
2. 不用自己增加虚拟字段。（默认的枚举元素序号都是递增的整型，相邻的枚举元素序号差值不超过1）

例如(下面的枚举元素没有序号11，但是不必设置一个虚拟的元素占位)：

```java

public enum Ensemble {
    SOLO(1), DUET(2), TRIO(3), QUARTET(4), QUINTET(5),
    SEXTET(6), SEPTET(7), OCTET(8), DOUBLE_QUARTET(8),
    NONET(9), DECTET(10), TRIPLE_QUARTET(12);

    private final int numberOfMusicians;
    
    Ensemble(int size) { this.numberOfMusicians = size; }
    public int numberOfMusicians() { return numberOfMusicians; }
}

```



> 带描述的枚举类：
>
> ```java
> /**
>  * 带描述的枚举
>  */
> public enum Ensemble {
>     ONE(1, "first one"),
>     TWO(2, "second one"),
>     THREE(3, "third one");
> 
>     private int value;
>     private String msg;
> 
>     Ensemble(int value, String msg) {
>         this.value = value;
>         this.msg = msg;
>     }
> 
>     public int getValue() {
>         return value;
>     }
> 
>     public String getMsg() {
>         return msg;
>     }
> }
> ```



---

***Reference***:

1. [Item 35: Use instance fields instead of ordinals（使用实例字段替代序数）](https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/dev/Chapter-6/Chapter-6-Item-35-Use-instance-fields-instead-of-ordinals.md)
