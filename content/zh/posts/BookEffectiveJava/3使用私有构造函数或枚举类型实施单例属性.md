---
title: 3-使用私有构造函数或枚举类型实施单例属性
date: 2021-10-21T14:23:06+08:00
description: Enforce the singleton property with a private constructor or an enum type.
draft: true
hideToc: false
enableToc: true
enableTocContent: false
tocPosition: outer
author: Victor
authorEmoji: 👻
image:
plantuml: true
libraries:
- katex
- mathjax
tags:
- EffectiveJava
- 单例模式
series:
- EffectiveJava
categories:
-
---



<!--第二章：创建和销毁对象-->

### 什么是单例？

单例是一个只实例化一次的类，并且通常表示无状态的对象。



### 如何实现单例

单例模式的实现，主要由三个步骤组成，即：

1. 声明一个静态私有的成员变量；
2. 私有化构造函数；
3. 声明一个静态共有的函数，函数返回该对象的实例。



实现单例有两种常见的方法。两者都基于**保持构造函数私有和导出公共静态成员**以提供对唯一实例的访问。

#### 方法1：使用公有的final域

一旦初始化了 Elvis 类，就只会存在一个 Elvis 实例，不多也不少。

```java
// Singleton with public final field
public class Elvis {
    public static final Elvis INSTANCE = new Elvis();
    private Elvis() { ... }
    public void leaveTheBuilding() { ... }
}
```

但有一点需要注意：拥有特殊权限的客户端可以借助 `AccessibleObject.setAccessible` 方法利用反射调用私有构造函数。如果需要防范这种攻击，请修改构造函数，使其在请求创建第二个实例时抛出异常。

```java
Constructor<?>[] constructors = Elvis.class.getDeclaredConstructors();
AccessibleObject.setAccessible(constructors, true);

Arrays.stream(constructors).forEach(name -> {
    if (name.toString().contains("Elvis")) {
        Elvis instance = (Elvis) name.newInstance();
        instance.leaveTheBuilding();
    }
});
```



#### 方法2：使用静态工厂方法

公共成员是一种静态工厂方法，所有对 `getInstance()` 方法的调用都返回相同的对象引用，并且不会创建其他 Elvis 实例（与前面提到的警告相同）。

```java
// Singleton with static factory
public class Elvis {
    private static final Elvis INSTANCE = new Elvis();
    private Elvis() { ... }
    public static Elvis getInstance() { return INSTANCE; }
    public void leaveTheBuilding() { ... }
}
```



> 方法1使用公共字段方法的主要优点是 API 明确了类是单例的：public static 修饰的字段是 final 的，因此它总是包含相同的对象引用。而方法2优点是更简单。



### 序列化的实现

要使单例类使用这两种方法中的任何一种实现可序列化（Chapter 12），仅仅在其声明中添加实现 serializable 是不够的。要维护单例保证，应声明所有实例字段为 transient，并提供 readResolve 方法（[Item-89](https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/dev/Chapter-12/Chapter-12-Item-89-For-instance-control-prefer-enum-types-to-readResolve.md)）。否则，每次反序列化实例时，都会创建一个新实例，在我们的示例中，这会导致出现虚假的 Elvis。

下面这个测试类：

```java
public class SerializableTest {

    public static void main(String[] args) throws Exception {
        // 序列化Singleton实例
        serializable(Sigleton.getInstance(), "test");
        // 反序列化该实例
        Sigleton singleton = deserializable("test");
        // 检查序列化前和序列化后的实例是否相等
        if (singleton != Sigleton.getInstance()) {
            System.out.println("singleton: " + singleton.toString());
            System.out.println("Singleton.getInstance: " + Sigleton.getInstance());
            System.out.println("two instances are different\n");
        } else {
            System.out.println("two instances are the same\n");
        }
    }

    //序列化
    private static void serializable(Sigleton singleton, String filename) throws IOException {
        FileOutputStream fos = new FileOutputStream(filename);
        ObjectOutputStream oos = new ObjectOutputStream(fos);
        oos.writeObject(singleton);
        oos.flush();
    }

    //反序列化
    @SuppressWarnings("unchecked")
    private static <T> T deserializable(String filename)
        throws IOException, ClassNotFoundException {
        FileInputStream fis = new FileInputStream(filename);
        ObjectInputStream ois = new ObjectInputStream(fis);
        return (T) ois.readObject();
    }
}


class Sigleton implements Serializable {

    private static final Sigleton INSTANCE = new Sigleton();

    private Sigleton() {
    }

    public static Sigleton getInstance() {
        return INSTANCE;
    }
}
```

运行之后输出：

```
two instances are different
```

显示两个单例对象不是同一个。



因为需要提供 readResolve 方法，为了防止这种情况发生，将这个 readResolve 方法添加到 Elvis 类中：

```diff
class Sigleton implements Serializable {

    private static final Sigleton INSTANCE = new Sigleton();

    private Sigleton() {
    }

    public static Sigleton getInstance() {
        return INSTANCE;
    }

+    private Object readResolve() {
+        return INSTANCE;
+    }
}
```

此时能够在序列化的时候得到两个相同的单例了：

```
two instances are the same
```



#### 方法3：声明一个单元素枚举

虽然在Sigleton单例类中添加readResolve函数能够解决序列化单例对象的问题，但是利用枚举来强化Singlton是一个更好的方法。

这种方法就是使用enum封装了一个单例的实例对象。因为Enum自带序列化的能力，所以非常方便。

```java
// Enum singleton - the preferred approach
public enum Elvis {
    INSTANCE;
    public void leaveTheBuilding() { ... }
}
```

实际的简单例子如下：

```java
public enum SingletonEnum {
    /** * 实例 */
    INSTANCE,A;

    private String field;

    public String getField() {
        return field;
    }

    public void setField(String field) {
        this.field = field;
    }
}

// 使用
SingletonEnum.INSTANCE.setField("123");
System.out.println(SingletonEnum.INSTANCE.getField());
```

这种方法类似于 public 字段方法，但是它更简洁，默认提供了序列化机制，提供了对多个实例化的严格保证，即使面对复杂的序列化或反射攻击也是如此。这种方法可能有点不自然，但是**单元素枚举类型通常是实现单例的最佳方法。** 



> 注意，如果你的单例必须扩展一个超类而不是 Enum（尽管你可以声明一个 Enum 来实现接口），你就不能使用这种方法。



---

***Reference***:

1. [用私有构造器或枚举来强化单例属性 - 林果的博客 | BY horizonliu](https://horizonliu.github.io/2019/01/08/%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E6%88%96%E6%9E%9A%E4%B8%BE%E6%9D%A5%E5%BC%BA%E5%8C%96%E5%8D%95%E4%BE%8B%E5%B1%9E%E6%80%A7/)
2. [Effective-Java-3rd-edition-Chinese-English-bilingual/Chapter-2-Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type.md at dev · clxering/Effective-Java-3rd-edition-Chinese-English-bilingual](https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/dev/Chapter-2/Chapter-2-Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type.md)

