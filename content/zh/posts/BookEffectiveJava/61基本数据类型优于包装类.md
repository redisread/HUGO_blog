---
title: 61基本数据类型优于包装类
date: 2021-11-19T11:16:43+08:00
description:
draft: true
hideToc: false
enableToc: true
enableTocContent: false
tocPosition: outer
author: Victor
authorEmoji: 🪶
image:
plantuml: true
libraries:
- katex
- mathjax
tags:
-
series:
-
categories:
-
---



基本类型和包装类型对应表

| 原始数据类型 | 包装类型 |
| ------------ | -------- |
| int          | Integer  |
| long         | Long     |
| boolean      | Boolean  |
| float        | Float    |
| double       | Double   |
|              |          |

自动装箱和拆箱机制虽然简化了代码的编写，在实际的运行中会进行自动的转化。但是，往往是这种转化导致出现一些逻辑不一样的问题，因为，毕竟基本类型和包装类型还是不一样的。



基本类型和包装类型的区别：

1. 基本类型只有值，包装类型还有其他成员变量和操作的API。
2. 基本类型只能设置值，但是包装类型能够设置null。



### 装箱拆箱问题

#### 逻辑错误

考虑下面的比较接口，使用了包装类型作为入参，然后进行自然的比较：

```java
Comparator<Integer> naturalOrder = (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```

当我们执行：

```java
naturalOrder.compare(new Integer(42), new Integer(42))
```

期望的输出是0，但是输出1。



这是因为

1. 在进行 `>` 和 `<` 这些比较的时候，会自动拆箱，将包装类型转化为基本类型。
2. 在进行 `==` 比较的时候，没有进行拆箱操作。



代码进行转化后大概是这样子的：

```java
Comparator<Integer> naturalOrder = (i, j) -> (i(int) < j(int)) ? -1 : (i(Integer) == j(Integer) ? 0 : 1);
```



而包装类进行`==` 比较的时候是比较两个对象的引用地址，两个对象不是同一个对象，所以输出了1。



> **将 `==` 操作符应用于包装类型几乎都是错误的**



正确修改方法可以是这样：

```java
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
    int i = iBoxed, j = jBoxed; // Auto-unboxing
    return i < j ? -1 : (i == j ? 0 : 1);
};
```

或者使用 `Comparator.naturalOrder()`



#### 速度变慢

考虑下面的函数

```java
// Hideously slow program! Can you spot the object creation?
public static void main(String[] args) {
    Long sum = 0L;
    for (long i = 0; i < Integer.MAX_VALUE; i++) {
        sum += i; // 装箱
    }
    System.out.println(sum);
}
```

因为频繁的自动装箱和拆箱导致代码的执行效率低。导致不必要的对象创建了。



### 什么时候使用包装类型

1. 使用范型容器时候必须使用包装类型。（Set、List、Map等）



总之，只要有选择，就应该优先使用基本类型，而不是包装类型。基本类型更简单、更快。如果必须使用包装类型，请小心！



---

***Reference***:

