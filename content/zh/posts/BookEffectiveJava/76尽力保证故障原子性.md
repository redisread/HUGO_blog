---
title: 76尽力保证故障原子性
date: 2021-11-25T17:59:23+08:00
description:
draft: true
hideToc: false
enableToc: true
enableTocContent: false
tocPosition: outer
author: Victor
authorEmoji: 🪶
image:
plantuml: true
libraries:
- katex
- mathjax
tags:
-
series:
-
categories:
-
---





在对象抛出异常之后，通常希望对象仍然处于定义良好的可用状态，即使在执行操作时发生了故障。对于 checked 异常尤其如此，调用者希望从异常中恢复。**一般来说，失败的方法调用应该使对象处于调用之前的状态。** 具有此属性的方法称为具备故障原子性。



如何保障故障原子性：

1. 使用不可变对象。
2. 对计算进行排序，使的可能发生故障的部分都先于修改对象的部分发生（例如在进行修改之前检查检查参数的有效性或者抛出错误）。
3. 使用对象的临时副本进行操作。

> 实现故障原子性的最后一种不太常见的方法是**编写恢复代码**，拦截在操作过程中发生的故障，并使对象回滚到操作开始之前的状态。这种方法主要用于持久的（基于磁盘的）数据结构。



总之，作为规则，也作为方法规范的一部分，生成的任何异常都应该使对象保持在方法调用之前的状态。如果违反了这条规则，API 文档应该清楚地指出对象将处于什么状态。

---

***Reference***:

1. [Effective-Java-3rd-edition-Chinese-English-bilingual/Chapter-10-Item-76-Strive-for-failure-atomicity.md at dev · clxering/Effective-Java-3rd-edition-Chinese-English-bilingual](https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/dev/Chapter-10/Chapter-10-Item-76-Strive-for-failure-atomicity.md)
