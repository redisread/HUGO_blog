---
title: 50在需要时制作防御性副本
date: 2021-11-14T15:38:12+08:00
description:
draft: true
hideToc: false
enableToc: true
enableTocContent: false
tocPosition: outer
author: Victor
authorEmoji: 🪶
image:
plantuml: true
libraries:
- katex
- mathjax
tags:
-
series:
-
categories:
-
---



### 防御性副本

将原来的对象进行拷贝，这就是防御性副本。然后再对防御性副本进行操作，就不会影响原来的对象了。



即使使用一种安全的语言，如果你不付出一些努力，也无法与其他类隔离。**你必须进行防御性的设计，并假定你的类的客户端会尽最大努力破坏它的不变量。** 随着人们越来越多地尝试破坏系统的安全性，这个观点越来越正确，但更常见的情况是，你的类将不得不处理程序员的无意错误所导致的意外行为。无论哪种方式，都值得花时间编写一个健壮的类来面对行为不轨的客户端。



### 构建健壮的类

下面是一个表示不可变时间段的类：

```java
// Broken "immutable" time period class
public final class Period {
    private final Date start;
    private final Date end;

    /**
    * @param start the beginning of the period
    * @param end the end of the period; must not precede start
    * @throws IllegalArgumentException if start is after end
    * @throws NullPointerException if start or end is null
    */
    public Period(Date start, Date end) {
        if (start.compareTo(end) > 0)
            throw new IllegalArgumentException(start + " after " + end);
        this.start = start;
        this.end = end;
    }

    public Date start() {
        return start;
    }

    public Date end() {
        return end;
    }
    ... // Remainder omitted
}
```



在构造函数和getter函数进行防御式副本改造，得到：

```java
// Broken "immutable" time period class
public final class Period {
    private final Date start;
    private final Date end;

    public Period(Date start, Date end) {
      // 将防御性副本赋值给类属性
        this.start = new Date(start.getTime());
        this.end = new Date(end.getTime());
        if (this.start.compareTo(this.end) > 0)
            throw new IllegalArgumentException(this.start + " after " + this.end);
    }
		
  	
    public Date start() {
      // 返回防御性副本
    	return new Date(start.getTime());
    }
		
    public Date end() {
      // 返回防御性副本
      return new Date(end.getTime());
    }
    ... // Remainder omitted
}
```



有了新的构造函数和新的访问器，Period 实际上是不可变的。无论程序员多么恶毒或无能，都不可能违背一个时间段的开始时间不能在结束时间之后这一不变条件。

> 在可能的情况下，应该使用不可变对象作为对象的组件，这样就不必操心防御性复制



为什么上述的方法没有使用clone方法返回一个副本？

因为 Date 不是 final 的，也就是他能够被继承，所以不能保证 clone 方法返回一个 java.util.Date 的实例对象：它可以返回一个**不受信任子类的实例**，这个子类是专门为恶意破坏而设计的。

所以，对可被不受信任方子类化的参数类型，不要使用 clone 方法进行防御性复制。

getter方法虽然已经知道了实例对象是 java.util.Date ，但是也最好不要使用clone方法，因为使用clone方法还需要进行重写，重写之后可能还是会出现问题，使用构造函数或者拷贝构造函数就能够解决。

所以，一般情况下，最好使用构造函数或静态工厂来复制实例。





总而言之，如果一个类具有从客户端获取或返回给客户端的可变组件，则该类必须防御性地复制这些组件。如果复制的成本过高，并且类信任它的客户端不会不适当地修改组件，那么可以不进行防御性的复制，取而代之的是在文档中指明客户端的职责是不得修改受到影响的组件。







---

***Reference***:

