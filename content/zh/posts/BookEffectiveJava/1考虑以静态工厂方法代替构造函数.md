---
title: 1-考虑以静态工厂方法代替构造函数-《Effective Java》笔记
date: 2021-10-16T16:42:14+08:00
description: Consider static factory methods instead of constructors。
draft: false
hideToc: false
enableToc: true
enableTocContent: false
tocPosition: outer
author: Victor
authorEmoji: 👻
image: https://cos.jiahongw.com/uPic/image-20211016174809419.png
plantuml: true
libraries:
- katex
- mathjax
tags:
- EffectiveJava
series:
- EffectiveJava
categories:
-
---



<!--第二章：创建和销毁对象-->



### 什么是静态工厂方法？

一个类可以提供公共静态工厂方法，它只是一个返回类实例的静态方法。

例如Boolean （boolean 的包装类）的简单示例。该方法将 boolean 基本类型转换为 Boolean 对象的引用：

```java
public static Boolean valueOf(boolean b) {
	return b ? Boolean.TRUE : Boolean.FALSE;
}
```

> 要注意的是静态工厂方法与来自设计模式的工厂方法模式不同 [Gamma95]。本条目中描述的静态工厂方法在设计模式中没有直接等价的方法。



### 静态工厂方法的优点

#### 1 静态工厂方法有确切名称（更加清晰）

如果构造函数的参数本身并不能描述返回的对象，那么具有确切名称的静态工厂则更容易使用，生成的客户端代码也更容易阅读。最简单的例子，返回可能为素数的 BigInteger 类的构造函数 `BigInteger(int, int, Random)` 最好表示为名为 `BigInteger.probablePrime` 的静态工厂方法。

> 一个类只能有一个具有给定签名的构造函数。但是程序员可以通过提供多个构造函数来绕过这个限制，这些构造函数的参数列表仅在参数类型、个数或顺序上有所不同。**面对这样一个 API，用户将永远无法记住该用哪个构造函数，并且最终会错误地调用不适合的构造函数。如果不参考类文档，阅读使用这些构造函数代码的人就不会知道代码的作用。**



#### 2 静态工厂方法不需要在每次调用时创建新对象（节省内存）

`Boolean.valueOf(boolean)` 方法说明了这种技术：它从不创建对象。这种技术类似于享元模式 [Gamma95]。**如果经常请求相同的对象，特别是在创建对象的代价很高时，它可以极大地提高性能。**

> 什么是享元模式（Flyweight Design Pattern）？
>
> ***所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。***

**枚举类型也提供了这种保证。**



#### 3 可以通过静态工厂方法获取原返回类型的任何子类的对象（隐藏实现类）

这种灵活性的一个应用是 API可以返回对象，但又不会使对象的类变成共有的。（**类可以是私有的，通过共有的静态工厂方法进行返回**）以这种方式隐藏实现类会形成一个非常紧凑的 API。这种技术适用于基于接口的框架，其中**接口为静态工厂方法提供了自然的返回类型**。

> Collections 框架 API 比它导出 45 个独立的公共类要小得多，每个公共类对应一个方便的实现。减少的不仅仅是 API 的数量，还有概念上的减少：程序员为了使用 API 必须掌握的概念的数量和难度。程序员知道返回的对象是由相关的接口精确地指定的，因此不需要为实现类阅读额外的类文档。此外，使用这种静态工厂方法需要客户端通过接口而不是实现类引用返回的对象，这通常是很好的做法。



#### 4 返回对象的类可以随调用的不同而变化，作为输入参数的函数

也就是说，在构造函数(或者是我们需要构造的对象)和外界之间增加了一个静态工厂的方法作为中间层，这个中间层做一个小解耦，可以在中间层也就是静态工厂方法上执行自己的逻辑。例如：

​    EnumSet 类没有公共构造函数，只有静态工厂。在 OpenJDK 实现中，它们返回两个子类中的一个实例，这取决于底层 enum 类型的大小：如果它有 64 个或更少的元素，就像大多数 enum 类型一样，静态工厂返回一个 long 类型的 RegularEnumSet 实例；如果 enum 类型有 65 个或更多的元素，工厂将返回一个由 `long[]` 类型的 JumboEnumSet 实例。

> 客户端看不到这两个实现类的存在。如果 RegularEnumSet 不再为小型 enum 类型提供性能优势，它可能会在未来的版本中被消除，而不会产生不良影响。类似地，如果事实证明 EnumSet 有益于性能，未来的版本可以添加第三或第四个 EnumSet 实现。客户端既不知道也不关心从工厂返回的对象的类；它们只关心它是 EnumSet 的某个子类。



#### 5 当编写包含方法的类时，返回对象的类不需要存在（解耦，隔离）

这种灵活的静态工厂方法构成了服务提供者框架的基础，比如 Java 数据库连接 API（JDBC）。服务提供者框架是一个系统，其中提供者实现一个服务，系统使客户端可以使用这些实现，从而将客户端与实现分离。

> 也就是说，当需要一个对象的时候，使用静态工厂方法进行返回就可以了，不必真正的去创建这个类。



### 静态工厂方法的局限

#### 1 没有公共或受保护构造函数的类不能被子类化

例如，不可能在集合框架中子类化任何方便的实现类。这可能是一种因祸得福的做法，因为它鼓励程序员使用组合而不是继承，并且对于不可变的类型是必需的。

> 因为构造函数不是共有的或者是受保护的，子类就不能够访问父类的构造函数，从而不能够创建子类。（子类创建需要调用弗父类的构造函数在调用自己的构造函数）



#### 2 程序员很难找到这些静态工厂方法

它们在 API 文档中不像构造函数那样引人注目，因此很难弄清楚如何实例化一个只提供静态工厂方法而没有构造函数的类。与此同时，你可以通过在类或接口文档中对静态工厂方法多加留意，以及遵守通用命名约定的方式来减少这个困扰。下面是一些静态工厂方法的常用名称。这个列表还远不够详尽：

| 关键字                | 描述                                                         | 使用                                                         |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| from                  | 一种型转换方法，该方法接受单个参数并返回该类型的相应实例     | `Date d = Date.from(instant);`                               |
| of                    | 一个聚合方法，它接受多个参数并返回一个包含这些参数的实例     | `Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);`       |
| valueOf               | 一种替代 from 和 of 但更冗长的方法                           | `BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);`  |
| instance /getInstance | 返回一个实例，该实例由其参数（如果有的话）描述，但不具有相同的值 | `StackWalker luke = StackWalker.getInstance(options);`       |
| create /newInstance   | 与 instance 或 getInstance 类似，只是该方法保证每个调用都返回一个新实例 | `Object newArray = Array.newInstance(classObject, arrayLen);` |
| getType               | 类似于 getInstance，但如果工厂方法位于不同的类中，则使用此方法。其类型是工厂方法返回的对象类型 | `FileStore fs = Files.getFileStore(path);`                   |
| newType               | 与 newInstance 类似，但是如果工厂方法在不同的类中使用。类型是工厂方法返回的对象类型 | `BufferedReader br = Files.newBufferedReader(path);`         |
| type                  | 一个用来替代 getType 和 newType 的比较简单的方式             | `List<Complaint> litany = Collections.list(legacyLitany);`   |
|                       |                                                              |                                                              |



### 总结

静态工厂方法和公共构造器都有各自的用途，理解它们相比而言的优点是值得的。**通常静态工厂的方式更可取，因此应避免在没有考虑静态工厂的情况下就提供公共构造函数。**



---

***Reference***：

1. [Effective-Java-3rd-edition-Chinese-English-bilingual/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors.md at dev · clxering/Effective-Java-3rd-edition-Chinese-English-bilingual](https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/dev/Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors.md)

