---
title: 5-依赖注入优于硬连接资源
date: 2021-10-21T15:25:15+08:00
description: Prefer dependency injection to hardwiring resources.
draft: true
hideToc: false
enableToc: true
enableTocContent: false
tocPosition: outer
author: Victor
authorEmoji: 🪶
image:
plantuml: true
libraries:
- katex
- mathjax
tags:
- EffectiveJava
series:
- EffectiveJava
categories:
-
---



<!--第二章：创建和销毁对象-->



### 什么是硬连接资源

硬连接资源，我们可以理解为，一个类，依赖其它基础类，但是过于理想化，指定了它只连接一个基础类。



### 什么是依赖注入

将类中依赖的某种数据通过某种方法注入传输过去，这就是依赖注入。

![依赖注入](https://cos.jiahongw.com/uPic/image-20211021165816377.png)

### 如何实现依赖注入

假如，拼写检查程序依赖于字典。常见做法是，将这种类实现为静态实用工具类

```java
// Inappropriate use of static utility - inflexible & untestable!
public class SpellChecker {
    private static final Lexicon dictionary = ...;
    private SpellChecker() {} // Noninstantiable
    public static boolean isValid(String word) { ... }
    public static List<String> suggestions(String typo) { ... }
}
```

上面讲字典直接设置成了静态的不可变的成员，后续将不能进行更改，拓展性很差。除非是之后都不会改变这个字典，但是，字典是有很多种的。

要是换成单例模式，其实也是换汤不换药，单例只有一个，也是不能修改内容的。

```java
// Inappropriate use of singleton - inflexible & untestable!
public class SpellChecker {
    private final Lexicon dictionary = ...;
    private SpellChecker(...) {}
    public static INSTANCE = new SpellChecker(...);
    public boolean isValid(String word) { ... }
    public List<String> suggestions(String typo) { ... }
}
```

> 这里也说明了单例模式其实没有那么好，实现了单例就意味着失去了抽象，多态、继承等功能。



你可以尝试让 SpellChecker 支持多个字典：首先取消 dictionary 字段的 final 修饰，并在现有的拼写检查器中添加更改 dictionary 的方法。但是在并发环境中这种做法是笨拙的、容易出错的和不可行的。**静态实用工具类和单例不适用于由底层资源参数化的类。**

> 最好方法就是不使用静态方法。也不将内部的参数写死。



回到最初的办法，满足此要求的一个简单模式是在**创建新实例时将资源传递给构造函数。** 这是依赖注入的一种形式：字典是拼写检查器的依赖项，在创建它时被注入到拼写检查器中。

> 依赖注入模式非常简单，许多程序员在不知道其名称的情况下使用了多年。虽然拼写检查器示例只有一个资源（字典），但是依赖注入可以处理任意数量的资源和任意依赖路径。它保持了不可变性，因此多个客户端可以共享依赖对象（假设客户端需要相同的底层资源）。依赖注入同样适用于构造函数、静态工厂（[Item-1](https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/dev/Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors.md)）和构建器（[Item-2](https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/dev/Chapter-2/Chapter-2-Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters.md)）。

```java
// Dependency injection provides flexibility and testability
public class SpellChecker {
    private final Lexicon dictionary;
    public SpellChecker(Lexicon dictionary) {
        this.dictionary = Objects.requireNonNull(dictionary);
    }
    public boolean isValid(String word) { ... }
    public List<String> suggestions(String typo) { ... }
}
```

**这种模式的一个有用变体是将资源工厂传递给构造函数**。工厂是一个对象，可以反复调用它来创建类型的实例。这样的工厂体现了工厂方法模式。

```java
Mosaic create(Supplier<? extends Tile> tileFactory) { ... }
```

> Java 8 中引入的 `Supplier<T>` 非常适合表示工厂



**尽管依赖注入极大地提高了灵活性和可测试性，但它可能会使大型项目变得混乱，这些项目通常包含数千个依赖项。通过使用依赖注入框架（如 Dagger、Guice 或 Spring），几乎可以消除这种混乱。**



总之，**不要使用单例或静态实用工具类来实现依赖于一个或多个底层资源的类**，这些资源的行为会影响类的行为，**也不要让类直接创建这些资源**。相反，将创建它们的资源或工厂传递给构造函数（或静态工厂或构建器）。这种操作称为依赖注入，它将大大增强类的灵活性、可复用性和可测试性。

想要实现依赖注入，最好使用一些框架，避免重复造轮子。



---

***Reference***:

1. [ 05.依赖注入优先于硬连接资源_龚国玮的博客-CSDN博客_使用依赖注入取代硬连接资源](https://blog.csdn.net/qq_42678694/article/details/103949645)
2. [ JAVA8 Supplier接口_鸭鸭的博客-CSDN博客_java supplier](https://blog.csdn.net/qq_28410283/article/details/80625482)

