---
title: "Linux内存管理"
date: 2020-07-30T09:01:25+08:00
description:
draft: false
hideToc: false
enableToc: true
enableTocContent: false
tocPosition: inner
author: Victor
authorEmoji: 👻
image: https://gitee.com/wujiahong1998/MyBed/raw/master/img/linux.png
libraries:
- katex
- mathjax
tags:
- Linux
series:
- Linux
categories:
-
---



## 关于程序的装入

* 绝对装入：绝对映射，**程序中逻辑地址与内存物理地址完全相同**  （单片机)

* 可重定位装入：静态映射，**在装入时对逻辑地址进行修改**

* 动态运行时装入：逻辑地址到物理地址的**映射在程序运行时才执行**  (现代PC机)

![绝对装入与可重定向装入](https://i.loli.net/2020/07/29/jyb5Ee1IGSfvuCH.png)

而动态重定位如下：

![动态重定位](https://i.loli.net/2020/07/29/34N5dDC2ykI7Sbw.png)



> 静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。此外，作业一旦进入内存后，在整个运行期间不能在内存中移动，也不能再申请内存空间。

## 关于程序的链接

* 静态链接方式(Static Linking) 

  在程序运行之前，先将各目标模块及它们所需的库函数链接成**一个完整的可执行程序**，以后不再拆开。

* 装入时动态链接(Load time Dynamic Linking)

  将用户源程序编译后所得到的**一组目标模块**，在装入内存时，釆用边装入边链接的链接方式。

* 运行时动态链接(Run-time Dynamic Linking）

  对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。其优点是便于修改和更新，便于实现对目标模块的共享。



## 连续分配方式

### 单一连续分配

只能用于单用户、单任务的操作系统中。采用这种存储管理方式时，可把内存分为系统区和用户区两部分，系统区仅提供给 OS 使用，通常是放在内存的低址部分；用户区是指除系统区以外的全部内存空间，提供给用户使用。

![单一连续分配](https://i.loli.net/2020/07/29/k5bjYu76HTJLsZq.png)

### 固定分区连续分配

将内存用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业，这样，把用户空间划分为几个分区，便允许有几道作业并发运行。当有一空闲分区时，便可以再从外存的后备作业队列中选择一个适当大小的作业装入该分区，当该作业结束时，又可再从后备作业队列中找出另一作业调入该分区。

划分分区的方法：

1. 分区大小相等
2. 分区大小不相等

![固定分区](https://i.loli.net/2020/07/29/kEd7tIHwfrx63G8.png)

另外可以设置分区大小不等的一些分区，如下：

![大小不等的分区](https://i.loli.net/2020/07/29/pueabXT5gGNhxBw.png)

固定分区分配的缺点：

1. 造成存储空间的浪费
2. 拓展性差

### 动态分区分配

动态分区分配数据结构：

* **空闲分区表**

  在系统中设置一张空闲分区表，用于记录每个空闲分区的情况。每个空闲分区占一个表目，表目中包括分区序号、分区始址及分区的大小等数据项。

  ![空闲分区表](https://i.loli.net/2020/07/29/nZWN6wguUEBc9PL.png)

* **空闲分区链**

  为了实现对空闲分区的分配和链接，在每个分区的起始部分，设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针；在分区尾部则设置一后向指针，通过前、后向链接指针，可将所有的空闲分区链接成一个双向链，如下图所示：

  ![空闲分区链](https://i.loli.net/2020/07/29/AlP4bxTi1IZXfKU.png)

## 内存分配分配算法

### **基于顺序搜索**：(适合不太大的系统)

* **首次适应算法(FF)**

  在分配内存时，从链首开始顺序查找，直到找到一个大小能满足的空闲分区即可。然后再再按照作业的大小，从空间分区中划分出与作业大小相同的空间给作业使用，余下的空间留在空闲分区链中。

  > 首次适应算法要求空闲分区链以地址递增的次序链接。

  缺点：空闲分区链的低地址部分不断被划分，会有许多细小的碎片空间难以利用。每次都是从低地址开始找空闲分区，查找的效率低。

* **循环首次适应算法(NF)**

  循环首次适应算法在为进程分配内存空间时，**不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找**，直到找到一个能够满足进程的空闲分区为止，最后从空闲分区划分出与请求大小相等的空间给作业。

  > 循环到链表末尾又从新从链首开始查找。

  缺点：缺少可用的大空间空闲分区。

* **最佳适应算法(BF)**

  最佳适应算法在分配内存的时候，**把满足要求并且又是最小的空闲分区**给作业。为了加速寻找，该算法需要对空闲分区链按照空闲分区大小进行从小到大排序。

  缺点：会产生许多细小的碎片

* **最差适应算法(WF)**

  最差适应算法每次分配内存的时候，把**满足要求的最大的空闲分区**给作业，将与作业申请大小的空间划分出来，剩余的空间留在空闲分区中，并且更新空闲分区链。该算法需要对空闲分区链按照空闲分区大小进行从大到小排序。

  优点：查找效率块，产生碎片少。

  缺点：缺少大的空闲分区

例子：

假设有新程序F装入，大小为32K，当前已有程序B和D，最近一次空间分配是D：

![三种分配算法](https://i.loli.net/2020/07/29/RlPDx95WyXdtiAz.png)

### **基于索引搜索**：(适合比较大的系统)

* **快速适应算法(QF)**

  该算法又叫做分类搜索法，是将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设置一个空闲分区链，这样系统存在多个空闲分区链。同时，还需要在内存中设立一张管理索引表，其中的每一个索引表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头指针。

  > 空闲分区的分类是根据进程常用的空闲大小进行划分的，如2KB、4KB、8KB等，对于其他大小的空闲分区像7KB的空闲分区，既可以放在8KB的链表中，也可以放在一个特殊的空闲链表中。

* **伙伴系统**

  该算法规定，无论是分配分区还是空闲分区，其大小均为2的k次幂(k为整数且1<=k<=m)。通常$2^m$是整个可分配内存的大小。

  ![伙伴系统](https://i.loli.net/2020/08/19/Etgy5hYeZcHxwdv.png)

* **哈希算法**

  哈希算法是利用哈希快速查找的优点，以及空闲分区在可利用空闲分区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。

### **动态重定位分区分配**

**紧凑**

对内存中正在使用的分区进行搬迁，使多个小的空闲分区（碎片）合并为一个大的空闲分区

![紧凑](https://i.loli.net/2020/07/29/KoyMTUfF9u8JOjn.png)

**动态重定位**

![动态重定位](https://i.loli.net/2020/08/19/kSTxoNriw4vm7yV.png)

**算法**：

![算法](https://i.loli.net/2020/07/29/s8KPGeYHhLgdWJb.png)



什么是内存碎片？

内部碎片是指已经分配给作业但不能被利用的内存空间，外部碎片是指系统中还没有分配给作业，但由于碎片太小而无法分配给申请内存空间的新进程的存储块。通俗点的理解就是，某个作业所占用的内存区域如果没有装满，就是内部碎片，而作业与作业之间，如果有内存区域没有分配给某个作业，但又不能分配给任何作业，就是外部碎片。

![内存碎片](https://i.loli.net/2020/07/29/Ry2vBY8NTs9W54f.png)





> 连续分配: 为用户进程分配的必须是一个连续的内存空间。
> 非连续分配: 为用户进程分配的可以是一些分散的内存空间。

## 非连续分配方式

**思想**

假设进程A大小为23MB,但是每个分区大小只有10MB,如果进程只能占用一个分区,那显然放不下。
解决思路:

如果允许进程占用多个分区,那么可以把进程拆分成10MB+10MB+3MB三个部外,再把这三个部分分别放到三个分区中(这些分区不要求连续)...
进程A的最后一个部分是3MB,放入分区后会产生7MB的内部碎片，如果每个分区大小为2MB,那么进程A可以拆分成11*2MB +1MB共12个部分,只有最后一部分1MB占不满分区,共产生1MB的内部碎片.
*显然,如果把外区大小设置的更小一些,内部碎片会更小,内学利用率会更高*.

![非连续分配](https://i.loli.net/2020/07/29/K9JWX4b8LzHYVhs.png)







具有快表的地址变换机构：（时间局部性与空间局部性原理）

**快表**,又称联想寄存器(TLB) ,是一种访问速度比内存快很多的高速缓冲存储器,用来存放当"前访间的若干页表项,以加速地址变换的过程。与此对应,内存中的页表常称为慢表。

![TLB](https://i.loli.net/2020/07/29/NbM72vaBXtK8UET.png)





**多级页表**

问题

加载一个大的页表需要占用很大的内存

解决

将大表分为几个小表。类似CIDR。

可将长长的页表进行分组,使每个内存块刚好可以放入一个分组(比如上个侧子中,页面大小4KB,每个页表项48,每个页面可存放1K个页表项,因此每1K个连续的页表项为一组,每组刚好占一个内存块,再讲各组离散地放到各个内存块中)另外,要为离散分配的页表再建立一张页表,称为页目录表,或称外层页表,或称顶层页表







## 存储管理方式

### 分页存储管理





### 分段存储管理





### 段页式存储管理







---

参考链接：

1. [【操作系统 - 4】动态分区分配算法](https://blog.csdn.net/Houchaoqun_XMU/article/details/55541299)
2. [程序的链接的三种方式](https://blog.csdn.net/qq_36946274/article/details/81463522?biz_id=102&utm_term=%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-81463522&spm=1018.2118.3001.4187)
3. [连续分配管理方式](https://blog.csdn.net/xiaotai1234/article/details/107375547/?biz_id=102&utm_term=%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-107375547&spm=1018.2118.3001.4187)