---
title: "Linux内存管理"
date: 2020-07-30T09:01:25+08:00
description:
draft: false
hideToc: false
enableToc: true
enableTocContent: false
tocPosition: inner
author: Victor
authorEmoji: 👻
image: https://gitee.com/wujiahong1998/MyBed/raw/master/img/linux.png
libraries:
- katex
- mathjax
tags:
- Linux
series:
- Linux
categories:
-
---



## 关于程序的装入

* 绝对装入：绝对映射，**程序中逻辑地址与内存物理地址完全相同**  （单片机)

* 可重定位装入：静态映射，**在装入时对逻辑地址进行修改**

* 动态运行时装入：逻辑地址到物理地址的**映射在程序运行时才执行**  (现代PC机)

![绝对装入与可重定向装入](https://i.loli.net/2020/07/29/jyb5Ee1IGSfvuCH.png)

而动态重定位如下：

![动态重定位](https://i.loli.net/2020/07/29/34N5dDC2ykI7Sbw.png)



> 静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。此外，作业一旦进入内存后，在整个运行期间不能在内存中移动，也不能再申请内存空间。

## 关于程序的链接

* 静态链接方式(Static Linking) 

  在程序运行之前，先将各目标模块及它们所需的库函数链接成**一个完整的可执行程序**，以后不再拆开。

* 装入时动态链接(Load time Dynamic Linking)

  将用户源程序编译后所得到的**一组目标模块**，在装入内存时，釆用边装入边链接的链接方式。

* 运行时动态链接(Run-time Dynamic Linking）

  对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。其优点是便于修改和更新，便于实现对目标模块的共享。



## 连续分配方式

* 单一连续分配

  只能用于单用户、单任务的操作系统中。采用这种存储管理方式时，可把内存分为系统区和用户区两部分，系统区仅提供给 OS 使用，通常是放在内存的低址部分；用户区是指除系统区以外的全部内存空间，提供给用户使用。

  ![单一连续分配](https://i.loli.net/2020/07/29/k5bjYu76HTJLsZq.png)

* 固定分区连续分配

  将内存用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业，这样，把用户空间划分为几个分区，便允许有几道作业并发运行。当有一空闲分区时，便可以再从外存的后备作业队列中选择一个适当大小的作业装入该分区，当该作业结束时，又可再从后备作业队列中找出另一作业调入该分区。

  ![固定分区](https://i.loli.net/2020/07/29/kEd7tIHwfrx63G8.png)

  另外可以设置分区大小不等的一些分区，如下：

  ![大小不等的分区](https://i.loli.net/2020/07/29/pueabXT5gGNhxBw.png)

* 动态分区分配

  动态分区分配数据结构：

  * 空闲分区表

    在系统中设置一张空闲分区表，用于记录每个空闲分区的情况。每个空闲分区占一个表目，表目中包括分区序号、分区始址及分区的大小等数据项。

    ![空闲分区表](https://i.loli.net/2020/07/29/nZWN6wguUEBc9PL.png)

  * 空闲分区链

    为了实现对空闲分区的分配和链接，在每个分区的起始部分，设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针；在分区尾部则设置一后向指针，通过前、后向链接指针，可将所有的空闲分区链接成一个双向链，如下图所示：

    ![空闲分区链](https://i.loli.net/2020/07/29/AlP4bxTi1IZXfKU.png)

  分配算法：

  * 首次适应算法
  * 循环首次适应算法
  * 最佳适应算法
  * 最差适应算法
  * 快速适应算法

  例子：

  假设有新程序F装入，大小为32K，当前已有程序B和D，最近一次空间分配是D：

  ![三种分配算法](https://i.loli.net/2020/07/29/RlPDx95WyXdtiAz.png)

* 动态重定位分区分配

  对内存中正在使用的分区进行搬迁，使多个小的空闲分区（碎片）合并为一个大的空闲分区

  ![image-20200729103840445](https://i.loli.net/2020/07/29/KoyMTUfF9u8JOjn.png)

算法：

![image-20200729104102926](https://i.loli.net/2020/07/29/s8KPGeYHhLgdWJb.png)



什么是内存碎片？

内部碎片是指已经分配给作业但不能被利用的内存空间，外部碎片是指系统中还没有分配给作业，但由于碎片太小而无法分配给申请内存空间的新进程的存储块。通俗点的理解就是，某个作业所占用的内存区域如果没有装满，就是内部碎片，而作业与作业之间，如果有内存区域没有分配给某个作业，但又不能分配给任何作业，就是外部碎片。

![内存碎片](https://i.loli.net/2020/07/29/Ry2vBY8NTs9W54f.png)





> 连续分配: 为用户进程分配的必须是一个连续的内存空间。
> 非连续分配: 为用户进程分配的可以是一些分散的内存空间。

## 非连续分配方式

**思想**

假设进程A大小为23MB,但是每个分区大小只有10MB,如果进程只能占用一个分区,那显然放不下。
解决思路:

如果允许进程占用多个分区,那么可以把进程拆分成10MB+10MB+3MB三个部外,再把这三个部分分别放到三个分区中(这些分区不要求连续)...
进程A的最后一个部分是3MB,放入分区后会产生7MB的内部碎片，如果每个分区大小为2MB,那么进程A可以拆分成11*2MB +1MB共12个部分,只有最后一部分1MB占不满分区,共产生1MB的内部碎片.
*显然,如果把外区大小设置的更小一些,内部碎片会更小,内学利用率会更高*.

![非连续分配](https://i.loli.net/2020/07/29/K9JWX4b8LzHYVhs.png)







具有快表的地址变换机构：（时间局部性与空间局部性原理）

**快表**,又称联想寄存器(TLB) ,是一种访问速度比内存快很多的高速缓冲存储器,用来存放当"前访间的若干页表项,以加速地址变换的过程。与此对应,内存中的页表常称为慢表。

![TLB](https://i.loli.net/2020/07/29/NbM72vaBXtK8UET.png)





**多级页表**

问题

加载一个大的页表需要占用很大的内存

解决

将大表分为几个小表。类似CIDR。

可将长长的页表进行分组,使每个内存块刚好可以放入一个分组(比如上个侧子中,页面大小4KB,每个页表项48,每个页面可存放1K个页表项,因此每1K个连续的页表项为一组,每组刚好占一个内存块,再讲各组离散地放到各个内存块中)另外,要为离散分配的页表再建立一张页表,称为页目录表,或称外层页表,或称顶层页表





---

参考链接：

1. [【操作系统 - 4】动态分区分配算法](https://blog.csdn.net/Houchaoqun_XMU/article/details/55541299)
2. [程序的链接的三种方式](https://blog.csdn.net/qq_36946274/article/details/81463522?biz_id=102&utm_term=%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-81463522&spm=1018.2118.3001.4187)
3. [连续分配管理方式](https://blog.csdn.net/xiaotai1234/article/details/107375547/?biz_id=102&utm_term=%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-107375547&spm=1018.2118.3001.4187)