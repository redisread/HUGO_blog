---
title: linking
date: 2021-01-14T14:55:45+08:00
description: 链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。
draft: false
hideToc: false
enableToc: true
enableTocContent: false
tocPosition: outer
author: Victor
authorEmoji: 👻
image: https://i.loli.net/2021/01/22/GUJ5qKE16unSr7h.png
libraries:
- katex
- mathjax
tags:
- Linux
series:
-
categories:
-
---



# 链接

链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。

链接可以执行于编译时 (compile time) 也就是在源代码被翻译成机器代码时；也可以执行于加栽时（load time)，也就是在程序被加载器（loader)加载到内存并执行时；甚至执行于运行时（runtime)，也就是由应用程序来执行。

gcc的编译过程：

![gcc编译](https://i.loli.net/2021/02/03/rKLopw8IXO2Rd3D.png)

## 目标文件

> 编译器和汇编器生成可重定位目标文件(包括共享目标文件）。链接器生成可执行目标文件。

### 可重定位目标文件

包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。

下图是典型的ELF可重定位目标文件：

![ELF可重定位目标文件](https://i.loli.net/2021/02/02/6PJzrSikgMRDWc7.png)



这里需要注意的是，ELF 头（ELF header)以一个 16 字节的序列开始，这个序列描述了**生成该文件的系统的字的大小和字节顺序**。ELF 头剩下的部分包含**帮助链接器语法分析和解释目标文件的信息**。

帮助链接器语法分析和解释目标文件的信息包括：

- 括 ELF 头的大小
- 目标文件的类型
- 机器类型（如 X86-64)
- 节头部表的文件偏移
- 节头部表中条目的大小和数量

> 不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目（entry)

ELF 可重定位目标文件包含下面几个节：

- .text: 已编译程序的机器代码
- .rodata: 只读数据，比如printf语句中的格式串和switch语句的跳转表。
- .data: 已初始化的全局和静态 C 变量。(局部 C 变量在运行时被保存在栈中，既不出现在 .data 节中，也不出现在 .bss 节中)
- .-bss: 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。
- .symtab: —个符号表，它存放在程序中定义和引用的函数和全局变量的信息。
- .rel.text: —个.text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。
- .rel.data: 被模块引用或定义的所有全局变量的重定位信息。
- .debug: 一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。
- .line: 原始 C 源程序中的行号和.text 节中机器指令之间的映射。
- .strtab: —个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的令名字。



### 可执行目标文件

包含二进制代码和数据，其形式可以被直接复制到内存并执行。

![可执行目标文件](https://i.loli.net/2021/02/02/ifOWYzKPcatnRH4.png)



**加载可执行目标文件**

通过调用某个驻留在存储器中称为加载器（loader)的操作系统代码来运行它。任何Linux程序都可以通过execve 函数来调用加载器。

加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序复制到内存并运行的过程叫做加栽。

在 Linux X86-64系统中，代码段总是从地址 0x400加0 处开始，后面是数据段。运行时堆在数据段之后，通过调用 malloc 库往上增长。

用户栈总是从最大的合法用户地址（$2^{48}$ —1)开始，向较小内存地址增长。栈上的区域，从地址 $2^{48}$ 开始，是为内核（kernel)中的代码和数据保留的，所谓内核就是操作系统驻留在内存的部分。

Linux X86-64 运行时内存映像。没有展示出由于段对齐要求和地址空间布局随机化（ASLR)造成的空隙。

![image-20210203114305710](https://i.loli.net/2021/02/03/MudTPR7Z5sqoeQm.png)



加载器运行时，创建上面所示的内存映像。在程序头部表的引导下,加载器将可执行文件的片(chunk)复制到代码段和数据段。接下来，加载器跳转到程序的人口点，也就是`_start`函数的地址。这个函数是在系统目标文件 `ctrl.o` 中定义的，对所有的 C 程序都是一样的。`_start` 函数调用系统启动函数`__libc_start_main`，该函数定义在 `libc.so` 中。它初始化执行环境，调用用户层的 main 函数，处理 main 函数的返回值，并且在需要的时候把控制返回给内核。



### 共享目标文件

一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。



## 静态链接

> 像 **Linux** **LD** 程序这样的静态链接器（static linker)以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。

为了构造可执行文件，链接器必须完成两个主要任务：

1. **符号解析**：每个符号对应于一个函数、一个全局变量或一个静态变量
2. **重定位**：编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置



### 为什么使用静态链接库

早期的问题：不使用静态链接库，如何像用户提供标准函数？

**一种方法是让编译器辨认出对标准函数的调用，并直接生成相应的代码**。这种方法无疑会增加编译器的复杂性。(而且每次添

加、删除或修改一个标准函数时，就需要一个新的编译器版本)

**另一种方法是将所有的标准 C 函数都放在一个单独的可重定位目标模块中**。

这种方法的优点是它将编译器的实现与标准函数的实现分离开来，并且仍然对程序员保持适度的便利。然而，一个很大的缺点是系统中每个可执行文件现在都包含着一份标准函数集合的完全副本，这对磁盘空间是很大的浪费。另一个大的缺点是，对任何标准函数的任何改变，无论多么小的改变，都要求库的开发人员重新编译整个源文件，这是一个非常耗时的操作，使得标准函数的开发和维护变得很复杂

静态库概念被提出来，以解决这些不同方法的缺点。相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。

在链接时，链接器将**只复制被程序引用的目标模块**，这就减少了可执行文件在磁盘和内存中的大小。

### 使用静态链接库

要创建一个静态库，我们将使用 **AR** 工具

新建文件夹staticlib，在下面创建两个文件add.c和mul.c

```c
void add(int *x,int *y,int *z)
{
    *z = (*x) + (*y);
}
```

```c
void mul(int *x,int *y,int *z)
{
    *z = (*x) * (*y);
}
```

并且新建一个文件mymath.h，里面包含了上面两个文件的函数申明：

```c
void add(int *x,int *y,int *z);
void mul(int *x,int *y,int *z);
```

在文件夹staticlib下执行，编译成.o文件(就是一种可重定位文件)

```
gcc -c *.c
```

![image-20210202170429540](https://i.loli.net/2021/02/02/mYa9uPdKtb6iVr5.png)

使用 **AR** 工具生成静态链接库

```
ar rcs libmymath.a add.o mul.o
```

![image-20210202170632825](https://i.loli.net/2021/02/02/x3isJYEOMuXhc6I.png)

> 在 **Linux** 系统中，静态库以一种称为存档（archive)的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀**.a** 标识。

为了使用这个库，我们可以编写一个应用，与文件夹staticlib同级创建文件main.c

```c
#include <stdio.h>
#include "staticlib/mymath.h"

int main(int argc,const char *argv)
{
    int x = 1,y = 2;
    int z;
    printf("x = %d  y = %d \n",x,y);
    add(&x,&y,&z);
    printf("add: Z = %d\n",z);
    return 0;
}

```

```
gcc - c main.c
```

libc.a没有安装会报错，此时可以执行下面的语句安装：

```
yum install glibc-static
```

下面使用静态链接链接一个可执行文件

```
gcc -static -o main main.o ./staticlib/libmymath.a
```

或者

```
gcc -static -o main main.o -L staticlib/ -lmymath
```

`-static` 参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标文件，它可以加载到内存并运行，在加载时无须更进一步的链接。-lmymath 参数是 libvector.a 的缩写，-L.参数告诉链接器在当前目录下査找 libvector.a

![image-20210202192831297](https://i.loli.net/2021/02/02/heZzl6TPV7qN1wx.png)



大概的流程是下面这张图：

![静态链接](https://i.loli.net/2021/02/02/M8S7jwDIb4EZmdk.png)

当链接器运行时，它判定 main引用了add.o定义的 **add** 符号，所以复制add.o 到可执行文件。因为程序不引用任何由 **mul.o** 定义的符号，所以链接器就不会复制这个模块到可执行文件。链接器还会复制 **libc.a** 中的 **printf.o** 模块，以及许多 **C** 运行时系统中的其他模块。

> ar 是 Linux 的一个备份压缩命令，它可以将多个文件打包成一个备份文件（也叫归档文件），也可以从备份文件中提取成员文件。ar 命令最常见的用法是将目标文件打包为静态链接库。
>
> 对参数的说明：
>
> - 参数 r 用来替换库中已有的目标文件，或者加入新的目标文件。
> - 参数 c 表示创建一个库。不管库否存在，都将创建。　
> - 参数 s 用来创建目标文件索引，这在创建较大的库时能提高速度。
>

**使用静态链接库时，除了需要库文件本身，还需要对应的头文件：库文件包含了真正的函数代码，也即函数定义部分；头文件包含了函数的调用方法，也即函数声明部分。**

当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。

### 符号解析

**链接器如何解析静态链接库**？

在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。

链接器维护的三个集合：

- 可重定位目标文件集合E
- 未解析的符号集合U
- 已定义的符号集合D

初始时，三个集合都为空；最终的结果应该是集合U为空，才是链接成功，不然会报错。

![静态链接解析过程](https://i.loli.net/2021/02/03/7qxvD6pEnUXt9eY.png)



假如是目标文件

![目标文件解析](https://i.loli.net/2021/02/03/qaNwHxDYeu5EQ7t.png)



假如是存档文件，那么链接器就尝试匹配 U 中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员 m定义了一个符号来解析 U 中的一个引用，那么就将 m 加到 E中，并且链接器修改U 和 D来反映 m 中的符号定义和引用。对存档文件中所有的成员目标文件都依次进行这个过程，直到 U 和 D都不再发生变化。此时，任何不包含在 E中的成员目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。

![存档文件解析](https://i.loli.net/2021/02/03/7ld51CnLaxrTRIq.png)

最后，如果U是空集，它会合并和重定位 E中的目标文件，构建输出的可执行文件。



在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。(因为一开始集合U是空的，存档文件会假如E中，存档文件里面的定义永远不会被解析)

**关于库的一般准则是将它们放在命令行的结尾**。

### 重定位

此时，链接器就知道它的输人目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤中，将合并输人模块，并为每个符号分配运行时地址。重定位由两步组成：

> 注意下面一个是符号定义，一个是符号引用，两者不一样！

1. **重定位节和符号定义**

   在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输人模块的.data 节被全部合并成一个节，这个节成为输出的可执行目标文件的.data 节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输人模块定义的每个节，以及赋给输人模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。也就是指令段与代码段中全局、静态变量、函数入口以及指令的运行时内存地址都已确定。

   > 注意：
   >
   > .bss段在目标文件和可执行文件中并不占用文件的空间，但是它在装载时占用地址空间（占用的是虚拟地址空间）

2. **重定位节中的符号引用**

   这一步中，链接器修改代码节和数据节中对于每个符号的引用，使得他们指向正确的运行时地址。 这一步链接器依赖于可重定位目标模块中称为重定位条目的数据结构。

   参考地址：[https://blog.csdn.net/weixin_44176696/article/details/106666236](https://blog.csdn.net/weixin_44176696/article/details/106666236)

   **重定位条目**

   无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目 ，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在 .rel.text 中。已初始化数据的重定位条目放在 .rel.data 中。



## 动态链接

对于静态链接来说，它还是太消耗内存了。

共享库（shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接(dynamic linking)� 是由一个叫做动态链接器（dynamic linker)
的程序来执行的。

共享库是以两种不同的方式来“共享”：

- 在任何给定的文件系统，对于一个库只有一个.so 文件。

  所有引用该库的可执行目标文件共享这个.so文件中的代码和数据，而不是像静态库的内容那样被复制和嵌人到引用它们的可执行的文件中。

- 其次，在内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享。



基本的思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程。

没有任何 `libmymath.so` 的代码和数据节真的被复制到可执行文件 main 中。反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对  `libmymath.so` 中代码和数据的引用。

动态链接器通过执行下面的重定位完成链接任务：

- 重定位 `libc.so` 的文本和数据到某个内存段
- 重定位 `libmymath.so` 的文本和数据到另一个内存段
- 重定位 `main` 中所有对由 `libc.so` 和 `libmymath.so` 定义的符号的引用

最后，动态链接器将控制传递给应用程序。从这个时刻开始，共享库的位置就固定了，并且在程序执行的过程中都不会改变。

### 使用动态链接库

如果想创建一个动态链接库，可以使用 GCC 的`-shared`选项。输入文件可以是源文件、汇编文件或者目标文件。

另外还得结合`-fPIC`选项。-fPIC 选项作用于编译阶段，告诉编译器产生与位置无关代码（Position-Independent Code）；这样一来，产生的代码中就没有绝对地址了，全部使用相对地址，所以代码可以被加载器加载到内存的任意位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。

执行下面的命令，创建和使用动态链接库

```
gcc -shared -fpic -o libmymath.so add.c mul.c
gcc -o main main.c ./libmymath.so
```

-fPIC 选项作用于编译阶段，在生成目标文件时就得使用该选项，以生成位置无关的代码。

当然，必须要确保程序在运行时可以找到这个动态链接库。你可以将链接库放到标准目录下，例如 /usr/lib，或者设置一个合适的环境变量，例如 LIBRARY_PATH。不同系统，具有不同的加载链接库的方法。



---

参考：

1. [GCC创建和使用静态链接库（.a文件）](http://c.biancheng.net/view/7168.html)
2. [GCC生成动态链接库（.so文件）](http://c.biancheng.net/view/2385.html)
3. [C语言和C++的混合编译](http://c.biancheng.net/view/7494.html)