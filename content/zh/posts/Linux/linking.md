---
title: linking
date: 2021-01-14T14:55:45+08:00
description: 链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。
draft: false
hideToc: false
enableToc: true
enableTocContent: false
tocPosition: outer
author: Victor
authorEmoji: 👻
image: https://i.loli.net/2021/01/22/GUJ5qKE16unSr7h.png
libraries:
- katex
- mathjax
tags:
- Linux
series:
-
categories:
-
---



# 链接

链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。

链接可以执行于编译时 (compile time) 也就是在源代码被翻译成机器代码时；也可以执行于加栽时（load time)，也就是在程序被加载器（loader)加载到内存并执行时；甚至执行于运行时（runtime)，也就是由应用程序来执行。



## 目标文件

> 编译器和汇编器生成可重定位目标文件(包括共享目标文件）。链接器生成可执行目标文件。

### 可重定位目标文件

包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。

下图是典型的ELF可重定位目标文件：

![ELF可重定位目标文件](https://i.loli.net/2021/02/02/6PJzrSikgMRDWc7.png)



这里需要注意的是，ELF 头（ELF header)以一个 16 字节的序列开始，这个序列描述了**生成该文件的系统的字的大小和字节顺序**。ELF 头剩下的部分包含**帮助链接器语法分析和解释目标文件的信息**。

帮助链接器语法分析和解释目标文件的信息包括：

- 括 ELF 头的大小
- 目标文件的类型
- 机器类型（如 X86-64)
- 节头部表的文件偏移
- 节头部表中条目的大小和数量

> 不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目（entry)

ELF 可重定位目标文件包含下面几个节：

- .text: 已编译程序的机器代码
- .rodata: 只读数据，比如printf语句中的格式串和switch语句的跳转表。
- .data: 已初始化的全局和静态 C 变量。(局部 C 变量在运行时被保存在栈中，既不出现在 .data 节中，也不出现在 .bss 节中)
- .-bss: 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。
- .symtab: —个符号表，它存放在程序中定义和引用的函数和全局变量的信息。
- .rel.text: —个.text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。
- .rel.data: 被模块引用或定义的所有全局变量的重定位信息。
- .debug: 一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。
- .line: 原始 C 源程序中的行号和.text 节中机器指令之间的映射。
- .strtab: —个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的令名字。



### 可执行目标文件

包含二进制代码和数据，其形式可以被直接复制到内存并执行。

![可执行目标文件](https://i.loli.net/2021/02/02/ifOWYzKPcatnRH4.png)

### 共享目标文件

一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。



## 静态链接

> 像 **Linux** **LD** 程序这样的静态链接器（static linker)以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。

为了构造可执行文件，链接器必须完成两个主要任务：

1. **符号解析**：每个符号对应于一个函数、一个全局变量或一个静态变量
2. **重定位**：编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置



### 为什么使用静态链接库

早期的问题：不使用静态链接库，如何像用户提供标准函数？

一种方法是让编译器辨认出对标准函数的调用，并直接生成相应的代码。这种方法无疑会增加编译器的复杂性。(而且每次添

加、删除或修改一个标准函数时，就需要一个新的编译器版本)

另一种方法是将所有的标准 C 函数都放在一个单独的可重定位目标模块中。

这种方法的优点是它将编译器的实现与标准函数的实现分离开来，并且仍然对程序员保持适度的便利。然而，一个很大的缺点是系统中每个可执行文件现在都包含着一份标准函数集合的完全副本，这对磁盘空间是很大的浪费。另一个大的缺点是，对任何标准函数的任何改变，无论多么小的改变，都要求库的开发人员重新编译整个源文件，这是一个非常耗时的操作，使得标准函数的开发和维护变得很复杂







### 使用静态链接库

要创建一个静态库，我们将使用 **AR** 工具

新建文件夹staticlib，在下面创建两个文件add.c和mul.c

```c
void add(int *x,int *y,int *z)
{
    *z = (*x) + (*y);
}
```

```c
void mul(int *x,int *y,int *z)
{
    *z = (*x) * (*y);
}
```

并且新建一个文件mymath.h，里面包含了上面两个文件的函数申明：

```c
void add(int *x,int *y,int *z);
void mul(int *x,int *y,int *z);
```

在文件夹staticlib下执行，编译成.o文件(就是一种可重定位文件)

```
gcc -c *.c
```

![image-20210202170429540](https://i.loli.net/2021/02/02/mYa9uPdKtb6iVr5.png)

使用 **AR** 工具生成静态链接库

```
ar rcs libmymath.a add.o mul.o
```

![image-20210202170632825](https://i.loli.net/2021/02/02/x3isJYEOMuXhc6I.png)

为了使用这个库，我们可以编写一个应用，与文件夹staticlib同级创建文件main.c

```c
#include <stdio.h>
#include "staticlib/mymath.h"

int main(int argc,const char *argv)
{
    int x = 1,y = 2;
    int z;
    printf("x = %d  y = %d \n",x,y);
    add(&x,&y,&z);
    printf("add: Z = %d\n",z);
    return 0;
}

```

```
gcc - c main.c
```

libc.a没有安装会报错，此时可以执行下面的语句安装：

```
yum install glibc-static
```

下面使用静态链接链接一个可执行文件

```
gcc -static -o main main.o ./staticlib/libmymath.a
```

或者

```
gcc -static -o main main.o -L staticlib/ -lmymath
```

`-static` 参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标文件，它可以加载到内存并运行，在加载时无须更进一步的链接。-lmymath 参数是 libvector.a 的缩写，-L.参数告诉链接器在当前目录下査找 libvector.a

![image-20210202192831297](https://i.loli.net/2021/02/02/heZzl6TPV7qN1wx.png)



大概的流程是下面这张图：

![静态链接](https://i.loli.net/2021/02/02/M8S7jwDIb4EZmdk.png)

当链接器运行时，它判定 main引用了add.o定义的 **add** 符号，所以复制add.o 到可执行文件。因为程序不引用任何由 **mul.o** 定义的符号，所以链接器就不会复制这个模块到可执行文件。链接器还会复制 **libc.a** 中的 **printf.o** 模块，以及许多 **C** 运行时系统中的其他模块。

> ar 是 Linux 的一个备份压缩命令，它可以将多个文件打包成一个备份文件（也叫归档文件），也可以从备份文件中提取成员文件。ar 命令最常见的用法是将目标文件打包为静态链接库。
>
> 对参数的说明：
>
> - 参数 r 用来替换库中已有的目标文件，或者加入新的目标文件。
> - 参数 c 表示创建一个库。不管库否存在，都将创建。　
> - 参数 s 用来创建目标文件索引，这在创建较大的库时能提高速度。
>

使用静态链接库时，除了需要库文件本身，还需要对应的头文件：库文件包含了真正的函数代码，也即函数定义部分；头文件包含了函数的调用方法，也即函数声明部分。

当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。

### 链接器如何解析静态链接库



链接器维护的三个集合：



## 动态链接





### 生成动态链接库

如果想创建一个动态链接库，可以使用 GCC 的`-shared`选项。输入文件可以是源文件、汇编文件或者目标文件。

另外还得结合`-fPIC`选项。-fPIC 选项作用于编译阶段，告诉编译器产生与位置无关代码（Position-Independent Code）；这样一来，产生的代码中就没有绝对地址了，全部使用相对地址，所以代码可以被加载器加载到内存的任意位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。

例如，从源文件生成动态链接库：

```bash
$ gcc -fPIC -shared func.c -o libfunc.so
```

从目标文件生成动态链接库：

```bash
$ gcc -fPIC -c func.c -o func.o
$ gcc -shared func.o -o libfunc.so
```

-fPIC 选项作用于编译阶段，在生成目标文件时就得使用该选项，以生成位置无关的代码。



###  链接动态链接库

> GCC 将动态链接库链接到可执行文件

如果希望将一个动态链接库链接到可执行文件，那么需要在命令行中列出动态链接库的名称，具体方式和普通的源文件、目标文件一样。请看下面的例子

```bash
$ gcc main.c libfunc.so -o app.out
```

将 main.c 和 libfunc.so 一起编译成 app.out，当 app.out 运行时，会动态地加载链接库 libfunc.so。

当然，必须要确保程序在运行时可以找到这个动态链接库。你可以将链接库放到标准目录下，例如 /usr/lib，或者设置一个合适的环境变量，例如 LIBRARY_PATH。不同系统，具有不同的加载链接库的方法。





---

参考：

1. [GCC创建和使用静态链接库（.a文件）](http://c.biancheng.net/view/7168.html)
2. [GCC生成动态链接库（.so文件）](http://c.biancheng.net/view/2385.html)
3. [C语言和C++的混合编译](http://c.biancheng.net/view/7494.html)