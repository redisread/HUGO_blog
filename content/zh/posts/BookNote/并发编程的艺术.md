---
title: 并发编程的艺术
date: 2021-09-24T20:35:17+08:00
description:
draft: true
hideToc: false
enableToc: true
enableTocContent: false
tocPosition: outer
author: Victor
authorEmoji: 👻
image:
plantuml: true
libraries:
- katex
- mathjax
tags:
-
series:
-
categories:
-
---















## 并发的局限

### 1 局限

#### 上下文切换

即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。

频繁的上下文切换会影响多线程的执行速度。

#### 死锁

一旦产生死锁，就会造成系统功能不可用。

#### 资源限制

资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。更通俗的说，就是服务器给你串行的计算资源，你使用并发最好的情况也只能达到串行（可能更差）的效率，这个时候就需要考虑是否使用并发了。

常见的资源限制：

- 计算资源（CPU）
- 带宽
- 磁盘读写速度



> **并发一定会比串行快吗?**
>
> 当数据量比较小的时候，串行一般会比并发要快；在数据量大的时候，并发会比串行要快。所以并发不一定会比串行快，同时，还需要考虑上下文切换以及锁的消耗。



### 2 正确并发

#### 加快并发（减少上下文切换）

1. 无锁并发编程。

   所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。

2. CAS算法。

   Java的Atomic包使用CAS算法来更新数据，而不需要加锁。

3. 使用最少的线程。

   避免创建不必要的线程。根据任务量来判断线程的个数。

4. 使用协程。

   在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换

#### 可靠并发（避免死锁）

1. 避免一个线程同时获取多个锁。
2. 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
3. 尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。
4. 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。











