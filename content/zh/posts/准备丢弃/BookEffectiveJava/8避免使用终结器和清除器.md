---
title: 8-避免使用终结器和清除器
date: 2021-10-27T16:52:44+08:00
description: Avoid finalizers and cleaners.垃圾回收机制和终结器&清除器似乎是相反的两件事。垃圾回收机制企图让你不要管对象的清除，但是终结器&清除器却想自己掌控对象的清除。
draft: true
hideToc: false
enableToc: true
enableTocContent: false
tocPosition: outer
author: Victor
authorEmoji: 🪶
image:
plantuml: true
libraries:
- katex
- mathjax
tags:
- EffectiveJava
series:
- EffectiveJava
categories:
-
---

<!--第二章：创建和销毁对象-->

### 什么是终结器和清除器？

#### 终结器（finalizers）

fnalize是基础类java.lang.Object的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。

`finalize()`:调用对象的终结器方法即可将对象从队列中删除

#### 清除器（cleaners）

Java平台目前在逐步使用java.lang.ref.Cleaner来替换掉原有的fnalize实现。Cleaner的实现利用了幻象引用(PhantomReference)，这是一种常见的所谓post-mortem清理 机制。利用幻象引用和引用队列，我们可以保证对象被彻底销毁前做一些类似资源回收的工作，比如关闭文件描述符(操作系统有限的 资源)，它比fnalize更加轻量、更加可靠。

> 吸取了fnalize里的教训，每个Cleaner的操作都是独立的，它有自己的运行线程，所以可以避免意外死锁等问题。

实践中，我们可以为自己的模块构建一个Cleaner，然后实现相应的清理逻辑。下面是JDK自身提供的样例程序:

```jade
public class CleaningExample implements AutoCloseable {
 // A cleaner, preferably one shared within a library private satic fnal Cleaner cleaner = <cleaner>; satic class State implements Runnable {
 State(...) {
  // initialize State needed for cleaning action
 }
 public void run() {
  // cleanup action accessing State, executed at mos once }
 }
 private fnal State;
 private fnal Cleaner.Cleanable cleanable public CleaningExample() {
  this.sate = new State(...);
  this.cleanable = cleaner.regiser(this, sate);
 }
 public void close() {
  cleanable.clean();
 }
}
```

注意，从可预测性的角度来判断，Cleaner或者幻象引用改善的程度仍然是有限的，如果由于种种原因导致幻象引用堆积，同样会出现问题。所以，Cleaner适合作为一种最后的保 证手段，而不是完全依赖Cleaner进行资源回收，不然我们就要再做一遍fnalize的噩梦了。

### 为什么最好不要使用终结器和清除器

终结器和清除器的一个缺点是不能保证它们会被立即执行。当对象变得不可访问，终结器或清除器对它进行操作的时间是不确定的。这意味着永远不应该在终结器或清除器中执行任何对时间要求很严格的操作。例如，依赖终结器或清除器关闭文件就是一个严重错误，因为打开的文件描述符是有限的资源。如果由于系统在运行终结器或清除器的延迟导致许多文件处于打开状态，程序可能会运行失败，因为它不能再打开其他文件。

在 Java 9 中，终结器已经被弃用，但是 Java 库仍然在使用它们。Java 9 替代终结器的是清除器。**清除器的危险比终结器小，但仍然不可预测、缓慢，而且通常是不必要的。**

> 垃圾回收机制和终结器&清除器似乎是相反的两件事。垃圾回收机制企图让你不要管对象的清除，但是终结器&清除器却想自己掌控对象的清除。

另外，使用终结器和清除器会严重影响性能。

### 什么时候使用终结器和清除器

#### 1 充当一个安全网

多数情况我们不需要重写 finalize 方法，只有当我们需要持有未托管资源的时候才需要，而此时重写 finalize 方法，只是作为一个“安全网”，不能作为常规的资源释放模式，必须提供显式的释放方法，如：close。通常来说，利用上面的提到的try-with-resources或者try-fnally机制，是非常好的回收资源的办法。如果确实需要额外处理，可以考虑Java提供的Cleaner机制或者其他替代方 法。

#### 2 涉及到与本机对等体的对象

本机对等点是普通对象通过本机方法委托给的本机（非 java）对象。因为本机对等点不是一个正常的对象，垃圾收集器不知道它，并且不能在回收 Java 对等点时回收它。如果性能是可接受的，并且本机对等体不持有任何关键资源，那么更清洁或终结器可能是完成这项任务的合适工具。如果性能不可接受，或者本机对等体持有必须立即回收的资源，则类应该具有前面描述的关闭方法。

---

***Reference***:

1. [Item 8: Avoid finalizers and cleaners（避免使用终结器和清除器）](https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/dev/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners.md)
