---
title: 7-排除过时的对象引用
date: 2021-10-27T11:45:11+08:00
description: Eliminate obsolete object references.
draft: true
hideToc: false
enableToc: true
enableTocContent: false
tocPosition: outer
author: Victor
authorEmoji: 🪶
image:
plantuml: true
libraries:
- katex
- mathjax
tags:
- EffectiveJava
series:
- EffectiveJava
categories:
-
---



<!--第二章：创建和销毁对象-->

> 虽然Java自带垃圾回收机制，但是我们还是因该自己做一些内存的管理。

### 过期的对象引用

> 什么是过期的对象引用？
>
> 指的是之后不会再使用的对象引用。

Stack中pop的实现如下：

```java
public class Stack {
    private Object[] elements;
    public Object pop() {
          if (size == 0)
              throw new EmptyStackException();
          return elements[--size]; // 只改变了下标，引用未改变，不会被回收
      }
}
```

在Stack先增长然后收缩，那么从堆栈中弹出的对象将不会被垃圾收集，即使使用堆栈的程序不再使用它们，但实际还是引用了它们。

> 由于垃圾收集器活动的增加或内存占用的增加，它可以悄无声息地表现为性能的降低。在极端情况下，这种内存泄漏可能导致磁盘分页，甚至出现 OutOfMemoryError 程序故障，但这种故障相对少见。

也就是说，**对于Java这种有垃圾回收机制的编程语言来说，也是会发生内存泄漏的**。

> 想要了解垃圾回收机制，最好从Java虚拟机入手。《深入理解Java虚拟机》

### 如何清除过期的引用

解决这类问题的方法很简单：**一旦引用过时，就将置空**。

```java
public Object pop() {
    if (size == 0)
        throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null; // Eliminate obsolete reference
    return result;
}
```

实际上，Java中的Vector类（Stack继承Vector）的实现也是这样的:

![Java-Vector实现](https://cos.jiahongw.com/uPic/image-20211027115105039.png)

> 用 null 处理过时引用的另一个好处是，如果它们随后被错误地关联引用，程序将立即失败，出现 NullPointerException，而不是悄悄地做错误的事情。尽可能快地检测编程错误总是有益的。

程序员必须自己判断过期的元素之后是否还需要使用，当不需使用的时候设置为null。一般来说，一个类管理它自己的内存时，程序员应该警惕内存泄漏。当释放一个元素时，该元素中包含的任何对象引用都应该被置为 null。

同样好需要我们警惕的会发生内存泄漏的地方：

1. 缓存。（一旦将对象引用放入缓存中，就很容易忘记它就在那里，并且在它变得无关紧要之后很久仍将它留在缓存中）
2. 监听器和其他回调。（如果你实现了一个 API，其中客户端注册回调，但不显式取消它们，除非你采取一些行动，否则它们将累积）

由于内存泄漏通常不会表现为明显的故障，它们可能会在系统中存在多年。它们通常只能通过仔细的代码检查或借助一种称为堆分析器的调试工具来发现。因此，学会在这样的问题发生之前预测并防止它们发生是非常可取的。

---

***Reference***:

1. [Item 7: Eliminate obsolete object references（排除过时的对象引用）](https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/dev/Chapter-2/Chapter-2-Item-7-Eliminate-obsolete-object-references.md)
