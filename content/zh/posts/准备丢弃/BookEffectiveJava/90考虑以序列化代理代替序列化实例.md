---
title: 90考虑以序列化代理代替序列化实例
date: 2021-11-21T14:14:46+08:00
description:
draft: true
hideToc: false
enableToc: true
enableTocContent: false
tocPosition: outer
author: Victor
authorEmoji: 🪶
image:
plantuml: true
libraries:
- katex
- mathjax
tags:
-
series:
-
categories:
-
---



> 实现 Serializable 接口的决定增加了出现 bug 和安全问题的可能性，因为它允许使用一种超语言机制来创建实例，而不是使用普通的构造函数。然而，有一种技术可以大大降低这些风险。这种技术称为序列化代理模式。

如何实现序列化代理 模式？

1. 为可序列化的类设计一个私有的静态嵌套类(序列化代理), 它应该有一个单独的构造器, 其参数类型就是那个外围类.

2. 在外围类中添加writeReplace方法. -> 产生代理类实例.

   这个方法的存在导致序列化系统产生一个SerializationProxy 实例，代替外围类的实例。换句话说， writeReplace 方法在序列化之前，将外围类的实例转变成了它的序列化代理。

3. 外围类中添加readObject方法. -> 防止伪造.

4. 代理类中提供readResolve方法, 返回一个逻辑上相当的外围类的实例. -> 序列化代理转变回外围类的实例.

一个例子：

```java
/**
 * 1. 序列化Dog时, 会调用调用writeReplace()生成一个DogProxy对象, 然后对此对象进行序列化 (不是对Dog类对象进行序列化,
 *      由序列化文件的内容可以得知, 可以查看序列化生成的文件, 文件中内容为如下图 (代码之后的图)
 * 2. 反序列化时, 会调用DogProxy的readResolve()方法生成一个Dog对象, 
 *      最后返回此对象的拷贝 (通过DogProxy类的readResolve方法和main方法中的输出可以看出)
 * 3. 因此, Dog类的序列化工作完全交给DogProxy类, 正如此模式的名称所表达的一样
 */
public class Dog implements Serializable{
    private static final long serialVersionUID = -8424740460257438938L;
    
    private String name;
    private int age;
    
    public Dog(String name,int age) {
        //约束条件
        if(age < 0 || age > 100) {
            throw new IllegalArgumentException("非法年龄");
        }
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    /** 序列化代理内部类 */
    private static class DogProxy implements Serializable{
        private static final long serialVersionUID = -8883457811799334207L;

        private String name;
        private int age;

        public DogProxy(Dog dog) {
            this.name = dog.getName();
            this.age = dog.getAge();
        }
        
        /** 反序列化时, 替换返回的对象(比喻偷天换日吧) */
        private Object readResolve() {
            return new Dog(name,age);
        }

        /** 自定义序列化形式 */
        private void writeObject(ObjectOutputStream out) throws IOException {
            out.defaultWriteObject();
            System.out.println("SerializationProxy writeObject, 调用");
        }

        /** 自定义反序列化形式 */
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            in.defaultReadObject();
            System.out.println("SerializationProxy readObject, 调用");
        }
        
    }

    /** 序列化时, 把this=Dog对象替换为序列化代理对象 */
    private Object writeReplace() {
        return new DogProxy(this);//readObject的时候是调用, DogProxy的readResolve()
    }

    /** 此方法不会执行 */
    private void writeObject(ObjectOutputStream out) {
        System.out.println("Dog writeObject, 不会调用");
    }
    
    /** 防止攻击者伪造数据, 企图违反约束条件 (如: 违反年龄约束) */
    private void readObject(ObjectInputStream in) throws Exception {
        throw new Exception("proxy required");
    }
    
}
```

有点类似建造者模式。

使用：

```java
public class Test {

    public static void main(String[] args) throws IOException, ClassNotFoundException {
        Dog dog = new Dog("小白",12);
        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("D:\\temp"));
        out.writeObject(dog);
        out.flush();
        out.close();
        
        
        ObjectInputStream in = new ObjectInputStream(new FileInputStream("D:\\temp"));
        Dog deserDog = (Dog)in.readObject();
        in.close();
        
        System.out.println(deserDog.getAge());
        System.out.println(deserDog.getName());
        
        if(dog == deserDog) {
            System.out.println("序列化前后是同一个对象");
        } else {
            //程序会走这一段, 反序列化会创建对象, 但是不会执行类的构造方法, 而是使用输入流构造对象
            System.out.println("序列化前后不是同一个对象, 哈哈哈");
        }
        
    }
    
}
```

局限：

- 不能与可以被客户端扩展的类兼容.
- 不能与对象图中包含循环的某些类兼容.
- 序列化代理模式的功能和安全性有性能开销的代价.

总而言之, 每当你发现自己必须在一个不能被客户端扩展的类上编写readObject或者writeObject方法的时候, 就应该考虑使用序列化代理模式.

---

***Reference***:

1. [Effective-Java-3rd-edition-Chinese-English-bilingual/Chapter-12-Item-90-Consider-serialization-proxies-instead-of-serialized-instances.md at dev · clxering/Effective-Java-3rd-edition-Chinese-English-bilingual](https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/dev/Chapter-12/Chapter-12-Item-90-Consider-serialization-proxies-instead-of-serialized-instances.md)
