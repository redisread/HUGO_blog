---
title: 52明智地使用重载
date: 2021-11-14T17:25:37+08:00
description:
draft: true
hideToc: false
enableToc: true
enableTocContent: false
tocPosition: outer
author: Victor
authorEmoji: 🪶
image:
plantuml: true
libraries:
- katex
- mathjax
tags:
-
series:
-
categories:
-
---



函数的重载是在编译的时候就确定了的，很多时候容易认为它在运行时期自动判断执行哪个函数。例如下面这个例子：

```java
// Broken! - What does this program print?
public class CollectionClassifier {
    public static String classify(Set<?> s) {
        return "Set";
    }

    public static String classify(List<?> lst) {
        return "List";
    }

    public static String classify(Collection<?> c) {
        return "Unknown Collection";
    }

    public static void main(String[] args) {
        Collection<?>[] collections = {
            new HashSet<String>(),new ArrayList<BigInteger>(),new HashMap<String, String>().values()
        };
        for (Collection<?> c : collections)
            System.out.println(classify(c));
    }
}
```

期望这个程序打印 Set，然后是 List 和 Unknown Collection，但是它没有这样做。它打印 Unknown Collection 三次。因为在编译期唯一适配三个实例的函数就只有 `public static String classify(Collection<?> c)`

> 重载方法的选择是静态的，而覆盖法的选择是动态的

修复 CollectionClassifier 程序的最佳方法是用一个执行显式 instanceof 测试的方法替换 classification 的所有三个重载：

```java
public static String classify(Collection<?> c) {
    return c instanceof Set ? "Set" :c instanceof List ? "List" : "Unknown Collection";
}
```

重载很容易混淆我们的期望，所以，应该避免混淆重载的用法。最保险的方法是永远不要编写具有相同数量参数的两个重载方法。或者为方法提供不同的名称，而不是重载他们。例如 `writeBoolean(boolean)`、`writeInt(int)` 和 `writeLong(long)`等方法。

> 对于构造函数，你没有使用不同名称的机会：一个类的多个构造函数只能重载。在很多情况下，你可以选择导出静态工厂而不是构造函数。你可能会有机会导出具有相同数量参数的多个构造函数，因此知道如何安全地执行是有必要的。

因为要对现有类进行改造以实现新接口，那么应该确保在传递相同的参数时，所有重载的行为都是相同的。如果你做不到这一点，程序员将很难有效地使用重载方法或构造函数，他们将无法理解为什么它不能工作。

> 例如，String 导出两个重载的静态工厂方法 `valueOf(char[])` 和 `valueOf(Object)`，它们在传递相同的对象引用时执行完全不同的操作。这样做没有真正的理由，它应该被视为一种异常行为，有可能造成真正的混乱。还有就是集合类set、list等的remove函数，有一些是删除指定的值，有一些是删除指定下标的值，很容易混乱。特别是Java有了自动装箱机制之后，这个又更加混乱了。

---

***Reference***:
